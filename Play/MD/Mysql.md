# MYSQL

## MVCC
`并发版本控制，将不同时间的数据加上版本和时间戳，每个版本都是成为一个快照，每个事务执行时都会加上一个时间戳，当MVCC下执行时会比较执行事务的时间是否晚于这个快照的时间戳，如果晚于这个时间戳就允许当前事务读取这个快照内地所有数据，否则不允许`

## $MySQL \ InnoDB \ 引擎的默认隔离级别是「可重复读」$

mysql默认情况下是快照读，无论最新数据是或否被delete、update、insert，一定不会出现幻读和不可重复读

如果手动使用select ... for update（当前读），那么一定会读到最新数据，如果只使用当前读，也不会出现幻读和不可重复读，因为select ... for update会自动加锁，当事务开始执行这条代码时会自动加上间隙锁，导致无法更新数据，避免幻读和不可重复读

如果同一个事务中限制性快照读又执行当前都那么一定会出现数据不同步问题，但是使用快照读就是为了读历史版本数据防止数据不一致，如果又同时拿了最新数据那么目的到底时拿最新的还是历史的？
如果那最新的就全用select ... for update一样不会出现数据不一致

另一个问题是在当前事务中更新了数据，导致快照时间更新允许当前事务读取更新后的快照数据，

，所以MySQL InnoDB 引擎的默认隔离级别「可重复读」完全不会出现幻读和不可重复读，除非自己作死不清楚自己要读什么数据

$针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。$

$针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。$

